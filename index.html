<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Eat What You Want</title>
  <style>
    :root{
  --bg:#f6f7fb;          /* ì „ì²´ ë°°ê²½ */
  --panel:#ffffff;       /* ì¹´ë“œ/íŒ¨ë„ */
  --text:#111827;        /* ê¸°ë³¸ ê¸€ì */
  --muted:rgba(17,24,39,.65);
  --line:rgba(17,24,39,.12);
  --btn:#eef2ff;
  --btn2:#e0e7ff;
}

body{
  margin:0;
  background:
    radial-gradient(1200px 700px at 20% 10%, rgba(90,140,255,.18), transparent 60%),
    radial-gradient(1000px 600px at 80% 20%, rgba(255,120,200,.14), transparent 55%),
    var(--bg);
  color:var(--text);
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif;
  min-height:100vh;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:22px;
}

.card{
  background:linear-gradient(180deg, rgba(255,255,255,.95), rgba(255,255,255,.88));
  border:1px solid var(--line);
  border-radius:16px;
  overflow:hidden;
  box-shadow:0 10px 30px rgba(0,0,0,.10);
}

.gameArea{
  position:relative;
  padding:12px;
  background:rgba(17,24,39,.03);
}

canvas{
  display:block;
  width:100%;
  height:auto;
  border-radius:14px;
  border:1px solid rgba(17,24,39,.12);
  background:#ffffff; /* ìº”ë²„ìŠ¤ ë°”íƒ•ë„ ë°ê²Œ */
}

    .hud{
      position:absolute;
      top:18px;
      left:18px;
      right:18px;
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      pointer-events:none;
      gap:10px;
      font-size:13px;
      color:rgba(234,242,255,.92);
      text-shadow:0 2px 10px rgba(0,0,0,.8);
    }
    .hud .box{
      background:rgba(0,0,0,.30);
      border:1px solid rgba(255,255,255,.12);
      padding:10px 12px;
      border-radius:12px;
      backdrop-filter: blur(6px);
    }
    .hud .box b{ font-weight:700; }
    .panel{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      padding:12px;
      background:rgba(255,255,255,.03);
      border-top:1px solid var(--line);
    }
    button{
      appearance:none;
      border:1px solid var(--line);
      background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:650;
      transition:.15s transform, .15s background;
    }
    button:hover{ background:rgba(255,255,255,.06); }
    button:active{ transform:translateY(1px); }
    .ghostBtn{ background:linear-gradient(180deg, rgba(255,80,120,.18), rgba(255,80,120,.05)); }
    .okBtn{ background:linear-gradient(180deg, rgba(90,140,255,.22), rgba(90,140,255,.06)); }
    .row{
      display:flex;
      gap:10px;
      flex:1 1 280px;
      min-width:240px;
      align-items:center;
    }
    input{
      width:100%;
      border:1px solid var(--line);
      background:rgba(0,0,0,.20);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      outline:none;
    }
    input::placeholder{ color:rgba(234,242,255,.45); }
    .chips{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:center;
      width:100%;
    }
    .chip{
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.18);
      padding:6px 10px;
      border-radius:999px;
      font-size:13px;
      color:rgba(234,242,255,.92);
      display:flex;
      gap:8px;
      align-items:center;
    }
    .chip .x{
      pointer-events:auto;
      cursor:pointer;
      user-select:none;
      opacity:.75;
      font-weight:800;
    }
    .chip .x:hover{ opacity:1; }

    /* ëª¨ë°”ì¼ ë°©í–¥íŒ¨ë“œ (ì„ íƒ) */
    .dpad{
      position:absolute;
      bottom:18px;
      left:18px;
      display:none;
      gap:10px;
      pointer-events:auto;
      user-select:none;
    }
    .dpad button{ width:54px; height:54px; }
    @media (max-width: 720px){
      .hint{ text-align:left; }
      .dpad{ display:flex; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>ğŸ½ï¸ Eat What You Want</h1>
      </div>
      <p class="hint">
        ì´ë™: ë°©í–¥í‚¤/WASD Â· ì‹œì‘: Space/Start Â· ì¼ì‹œì •ì§€: P Â· ë¦¬ì…‹: R<br/>
        ëª©í‘œ: ë¨¹ê³  ì‹¶ì€ ê±° ë‹¤ ë¨¹ê¸°(ğŸ•ğŸœğŸ°) + â€œGuiltâ€ ìœ ë ¹ í”¼í•˜ê¸° ğŸ‘»
      </p>
    </header>

    <div class="card">
      <div class="gameArea">
        <canvas id="game" width="800" height="576"></canvas>

        <div class="hud">
          <div class="box" id="leftHud"></div>
          <div class="box" id="rightHud"></div>
        </div>

        <div class="dpad" id="dpad">
          <div style="display:flex;flex-direction:column;gap:10px;">
            <button id="upBtn">â†‘</button>
            <div style="display:flex;gap:10px;">
              <button id="leftBtn">â†</button>
              <button id="downBtn">â†“</button>
              <button id="rightBtn">â†’</button>
            </div>
          </div>
        </div>
      </div>

      <div class="panel">
        <button class="okBtn" id="startBtn">Start</button>
        <button id="pauseBtn">Pause</button>
        <button class="ghostBtn" id="resetBtn">Reset</button>

        <div class="row">
          <input id="foodInput" placeholder="ì¶”ê°€í•˜ê³  ì‹¶ì€ ìŒì‹/ì´ëª¨ì§€ (ì˜ˆ: ğŸœ, ë–¡ë³¶ì´, ice cream)" />
          <button id="addFoodBtn">Add</button>
        </div>

        <div class="chips" id="foodChips"></div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ====== MAP (25 x 18), TILE=32 => canvas 800x576 ======
  const TILE = 32;
  const MAP = [
    "#########################",
    "#........#.......#......#",
    "#.#####..#..###..#..#####",
    "#.#...#..#.......#......#",
    "#.#.#.#..####.#####.##..#",
    "#...#.#.......#.....##..#",
    "###.#.######..#.###.....#",
    "#...#......#..#...#######",
    "#.######.#.#..###.......#",
    "#......#.#.#......#####.#",
    "#.####.#.#.######.#.....#",
    "#.#....#.#........#.###.#",
    "#.#.####.########.#.#...#",
    "#.#.............#.#.###.#",
    "#.######.########.#.....#",
    "#.......#.........#..##.#",
    "#####..###..#####.#.....#",
    "#########################",
  ];
  const ROWS = MAP.length;
  const COLS = MAP[0].length;

  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  // ====== UI ======
  const leftHud = document.getElementById("leftHud");
  const rightHud = document.getElementById("rightHud");
  const startBtn = document.getElementById("startBtn");
  const pauseBtn = document.getElementById("pauseBtn");
  const resetBtn = document.getElementById("resetBtn");
  const foodInput = document.getElementById("foodInput");
  const addFoodBtn = document.getElementById("addFoodBtn");
  const foodChips = document.getElementById("foodChips");

  // ====== FOOD POOL (ê¸°ë³¸) ======
  const DEFAULT_FOODS = [
    "ğŸ•","ğŸ”","ğŸŸ","ğŸŒ­","ğŸ¥Ÿ","ğŸœ","ğŸ£","ğŸ™","ğŸ—","ğŸ¥©","ğŸ¥“",
    "ğŸ°","ğŸ§","ğŸ©","ğŸª","ğŸ«","ğŸ¦","ğŸ§","ğŸ­","ğŸ§‹","â˜•","ğŸ¥¤",
    "ğŸ“","ğŸ‡","ğŸ‰","ğŸŠ","ğŸŒ","ğŸ¥­","ğŸ’","ğŸ¥","ğŸ¥–","ğŸ§€"
  ];
  const STORAGE_KEY = "ewyw_custom_foods_v1";

  function loadCustomFoods(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      const arr = raw ? JSON.parse(raw) : [];
      return Array.isArray(arr) ? arr.filter(Boolean) : [];
    }catch{
      return [];
    }
  }
  function saveCustomFoods(arr){
    localStorage.setItem(STORAGE_KEY, JSON.stringify(arr.slice(0, 40)));
  }

  let customFoods = loadCustomFoods();

  function getFoodPool(){
    const merged = [...DEFAULT_FOODS, ...customFoods];
    // ì¤‘ë³µ ì œê±°
    return [...new Set(merged)];
  }

  function renderChips(){
    foodChips.innerHTML = "";
    if(customFoods.length === 0){
      const tip = document.createElement("div");
      tip.style.color = "rgba(234,242,255,.65)";
      tip.style.fontSize = "13px";
      tip.textContent = "Tip: ìœ„ ì…ë ¥ì¹¸ì— ìŒì‹/ì´ëª¨ì§€ë¥¼ ì¶”ê°€í•˜ë©´, ê²Œì„ì— ëœë¤ìœ¼ë¡œ ë“±ì¥í•´ìš”.";
      foodChips.appendChild(tip);
      return;
    }
    customFoods.forEach((f, idx) => {
      const chip = document.createElement("div");
      chip.className = "chip";
      chip.innerHTML = `<span>${escapeHtml(f)}</span><span class="x" title="ì‚­ì œ">Ã—</span>`;
      chip.querySelector(".x").addEventListener("click", () => {
        customFoods.splice(idx, 1);
        saveCustomFoods(customFoods);
        renderChips();
      });
      foodChips.appendChild(chip);
    });
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, c => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[c]));
  }

  addFoodBtn.addEventListener("click", () => {
    const v = foodInput.value.trim();
    if(!v) return;
    if(customFoods.includes(v)) { foodInput.value=""; return; }
    customFoods.unshift(v);
    customFoods = customFoods.slice(0, 30);
    saveCustomFoods(customFoods);
    foodInput.value = "";
    renderChips();
  });

  renderChips();

  // ====== AUDIO (ê°€ë²¼ìš´ ì‚‘ ì†Œë¦¬) ======
  let audioCtx = null;
  function beep(freq=520, ms=60, gain=0.03){
    try{
      if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = "sine";
      o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g).connect(audioCtx.destination);
      o.start();
      setTimeout(() => { o.stop(); }, ms);
    }catch{}
  }

  // ====== HELPERS ======
  const empties = [];
  for(let y=0; y<ROWS; y++){
    for(let x=0; x<COLS; x++){
      if(MAP[y][x] !== "#") empties.push({x,y});
    }
  }

  function isWallTile(tx, ty){
    if(tx<0 || ty<0 || tx>=COLS || ty>=ROWS) return true;
    return MAP[ty][tx] === "#";
  }

  function circleHitsWall(x, y, r){
    const pts = [
      {x:x-r, y:y-r},{x:x+r, y:y-r},{x:x-r, y:y+r},{x:x+r, y:y+r},
      {x:x, y:y-r},{x:x, y:y+r},{x:x-r, y:y},{x:x+r, y:y}
    ];
    for(const p of pts){
      const tx = Math.floor(p.x / TILE);
      const ty = Math.floor(p.y / TILE);
      if(isWallTile(tx, ty)) return true;
    }
    return false;
  }

  function dist2(ax, ay, bx, by){
    const dx=ax-bx, dy=ay-by;
    return dx*dx + dy*dy;
  }

  function pickEmptyTile(){
    return empties[(Math.random()*empties.length)|0];
  }

  function tileCenter(tx, ty){
    return { x: tx*TILE + TILE/2, y: ty*TILE + TILE/2 };
  }

  // ====== GAME STATE ======
  let state = "menu"; // menu | play | pause | over
  let score = 0;
  let lives = 3;
  let eaten = []; // ìµœê·¼ ë¨¹ì€ ìŒì‹
  let powerTimer = 0; // seconds
  let message = "Space ë˜ëŠ” Startë¡œ ì‹œì‘!";
  let tSinceSpawn = 0;

  const player = {
    x: TILE*1.5,
    y: TILE*1.5,
    r: 12,
    speed: 170,
    vx: 0, vy: 0
  };

  const ghosts = [];
  function makeGhost(x, y){
    return {
      x, y,
      r: 12,
      speed: 125,
      dir: {x:1, y:0},
      deadTimer: 0
    };
  }

  const foods = [];
  const MAX_FOODS = 38;

  function resetGame(){
    score = 0;
    lives = 3;
    eaten = [];
    powerTimer = 0;
    message = "Eat what you want. No guilt.";
    state = "menu";

    const p = tileCenter(1,1);
    player.x = p.x; player.y = p.y;

    ghosts.length = 0;
    const g1 = tileCenter(COLS-3, 1);
    const g2 = tileCenter(COLS-3, ROWS-3);
    ghosts.push(makeGhost(g1.x, g1.y));
    ghosts.push(makeGhost(g2.x, g2.y));

    foods.length = 0;
    for(let i=0;i<MAX_FOODS;i++) spawnFood();
  }

  function spawnFood(){
    const pool = getFoodPool();
    const {x:tx, y:ty} = pickEmptyTile();
    const c = tileCenter(tx, ty);

    // ì‹œì‘ ìœ„ì¹˜ ê·¼ì²˜ëŠ” ë„ˆë¬´ ë¹½ë¹½í•˜ì§€ ì•Šê²Œ
    if(dist2(c.x, c.y, player.x, player.y) < (TILE*3)*(TILE*3)) return;

    // ê°™ì€ ì¹¸ ì¤‘ë³µ ìŠ¤í° ë°©ì§€
    for(const f of foods){
      if(Math.floor(f.x/TILE)===tx && Math.floor(f.y/TILE)===ty) return;
    }

    const roll = Math.random();
    const isPower = roll < 0.10; // 10% í™•ë¥ ë¡œ "No Guilt" íŒŒì›Œí‘¸ë“œ
    const emoji = isPower ? "âœ¨" : pool[(Math.random()*pool.length)|0];

    foods.push({
      x: c.x,
      y: c.y,
      r: isPower ? 11 : 9,
      emoji,
      isPower
    });
  }

  resetGame();

  // ====== INPUT ======
  const keys = new Set();
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    keys.add(k);

    if(k === " "){
      e.preventDefault();
      if(state === "menu" || state === "over") startPlay();
    }
    if(k === "p"){
      if(state === "play") state = "pause";
      else if(state === "pause") state = "play";
    }
    if(k === "r"){
      resetGame();
      startPlay();
    }
  });
  window.addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));

  // ëª¨ë°”ì¼ D-pad
  function bindHold(btn, downKey){
    const down = () => keys.add(downKey);
    const up = () => keys.delete(downKey);
    btn.addEventListener("pointerdown", (e) => { e.preventDefault(); down(); });
    btn.addEventListener("pointerup", up);
    btn.addEventListener("pointercancel", up);
    btn.addEventListener("pointerleave", up);
  }
  bindHold(document.getElementById("upBtn"), "arrowup");
  bindHold(document.getElementById("downBtn"), "arrowdown");
  bindHold(document.getElementById("leftBtn"), "arrowleft");
  bindHold(document.getElementById("rightBtn"), "arrowright");

  // ====== BUTTONS ======
  startBtn.addEventListener("click", () => {
    if(state === "play") return;
    startPlay();
  });
  pauseBtn.addEventListener("click", () => {
    if(state === "play") state = "pause";
    else if(state === "pause") state = "play";
  });
  resetBtn.addEventListener("click", () => {
    resetGame();
    startPlay();
  });

  function startPlay(){
    if(state === "over") resetGame();
    state = "play";
    message = "Eat what you want. (P: pause)";
    beep(620, 70, 0.03);
  }

  // ====== UPDATE LOOP ======
  let last = performance.now();
  function tick(now){
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    if(state === "play"){
      update(dt);
    }
    draw();
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  function update(dt){
    // power timer
    if(powerTimer > 0) powerTimer = Math.max(0, powerTimer - dt);

    // movement input
    let ax = 0, ay = 0;
    if(keys.has("arrowleft") || keys.has("a")) ax -= 1;
    if(keys.has("arrowright") || keys.has("d")) ax += 1;
    if(keys.has("arrowup") || keys.has("w")) ay -= 1;
    if(keys.has("arrowdown") || keys.has("s")) ay += 1;

    // normalize (ëŒ€ê°ì„  ì†ë„ ë³´ì •)
    const mag = Math.hypot(ax, ay) || 1;
    ax /= mag; ay /= mag;

    const nx = player.x + ax * player.speed * dt;
    const ny = player.y + ay * player.speed * dt;

    // axis-separated collision
    let px = player.x, py = player.y;
    if(!circleHitsWall(nx, py, player.r)) px = nx;
    if(!circleHitsWall(px, ny, player.r)) py = ny;
    player.x = px; player.y = py;

    // eat foods
    for(let i=foods.length-1; i>=0; i--){
      const f = foods[i];
      const rr = player.r + f.r;
      if(dist2(player.x, player.y, f.x, f.y) <= rr*rr){
        foods.splice(i,1);
        if(f.isPower){
          powerTimer = 5.0;
          score += 80;
          message = "âœ¨ NO GUILT MODE! (5s)";
          beep(880, 90, 0.04);
        }else{
          score += 20;
          eaten.unshift(f.emoji);
          eaten = eaten.slice(0, 10);
          beep(680, 45, 0.028);
        }
      }
    }

    // respawn foods over time
    tSinceSpawn += dt;
    if(tSinceSpawn > 0.18){
      tSinceSpawn = 0;
      if(foods.length < MAX_FOODS) spawnFood();
    }

    // ghosts
    for(const g of ghosts){
      if(g.deadTimer > 0){
        g.deadTimer = Math.max(0, g.deadTimer - dt);
        if(g.deadTimer === 0){
          // respawn at corner
          const resp = tileCenter(COLS-3, ROWS-3);
          g.x = resp.x; g.y = resp.y;
          g.dir = {x:-1, y:0};
        }
        continue;
      }

      // choose direction when near tile center or blocked
      const tx = Math.floor(g.x / TILE);
      const ty = Math.floor(g.y / TILE);
      const c = tileCenter(tx, ty);
      const nearCenter = Math.abs(g.x - c.x) < 2.2 && Math.abs(g.y - c.y) < 2.2;

      const nextBlocked = (() => {
        const ntx = tx + g.dir.x;
        const nty = ty + g.dir.y;
        return isWallTile(ntx, nty);
      })();

      if(nearCenter || nextBlocked){
        const dirs = [
          {x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}
        ].filter(d => !isWallTile(tx + d.x, ty + d.y));

        // ë„ˆë¬´ ë¹ˆì•½í•˜ë©´ ê·¸ëŒ€ë¡œ
        if(dirs.length){
          // reverseëŠ” ì›¬ë§Œí•˜ë©´ í”¼í•˜ê¸°
          const rev = {x:-g.dir.x, y:-g.dir.y};
          const cand = dirs.filter(d => !(d.x===rev.x && d.y===rev.y));
          const use = cand.length ? cand : dirs;

          // ëª©í‘œ: power ì¤‘ì´ë©´ ë©€ì–´ì§€ê³ , ì•„ë‹ˆë©´ ê°€ê¹Œì›Œì§€ê¸°
          let best = use[0];
          let bestVal = powerTimer > 0 ? -Infinity : Infinity;

          for(const d of use){
            const nx = (tx + d.x)*TILE + TILE/2;
            const ny = (ty + d.y)*TILE + TILE/2;
            const dd = dist2(nx, ny, player.x, player.y);
            if(powerTimer > 0){
              // ë©€ìˆ˜ë¡ ì¢‹ìŒ
              if(dd > bestVal){ bestVal = dd; best = d; }
            }else{
              // ê°€ê¹Œìš¸ìˆ˜ë¡ ì¢‹ìŒ
              if(dd < bestVal){ bestVal = dd; best = d; }
            }
          }

          // ì•½ê°„ ëœë¤ì„±
          if(Math.random() < 0.08){
            best = use[(Math.random()*use.length)|0];
          }

          g.dir = best;
          // center snap
          g.x = c.x; g.y = c.y;
        }
      }

      const sp = g.speed * (powerTimer > 0 ? 0.85 : 1.0);
      const gx = g.x + g.dir.x * sp * dt;
      const gy = g.y + g.dir.y * sp * dt;

      // tile-based collision (ë²½ì´ë©´ ë©ˆì¶”ê³  ë‹¤ìŒ í”„ë ˆì„ì— ë°©í–¥ ì¬ì„ íƒ)
      if(!circleHitsWall(gx, gy, g.r)){
        g.x = gx; g.y = gy;
      }

      // collide with player
      const rr = g.r + player.r;
      if(dist2(g.x, g.y, player.x, player.y) <= rr*rr){
        if(powerTimer > 0){
          // eat ghost
          g.deadTimer = 1.2;
          score += 200;
          message = "ğŸ‘» nom nom. guilt OUT.";
          beep(220, 90, 0.04);
        }else{
          lives -= 1;
          message = lives > 0 ? "ğŸ‘» Guilt hitâ€¦ ê·¸ë˜ë„ ë¨¹ì–´! (ì ê¹ ë¬´ì )" : "Game Over. Rë¡œ ë‹¤ì‹œ!";
          beep(160, 130, 0.05);

          // ì ê¹ ë¬´ì : powerTimerë¥¼ ì•„ì£¼ ì§§ê²Œ ì£¼ëŠ” ë°©ì‹ìœ¼ë¡œ ì²˜ë¦¬(ìœ ë ¹ì´ ë©€ì–´ì§)
          powerTimer = 0.9;

          // player respawn
          const p2 = tileCenter(1,1);
          player.x = p2.x; player.y = p2.y;

          if(lives <= 0){
            state = "over";
          }
        }
      }
    }
  }

  // ====== DRAW ======
  function draw(){
    ctx.clearRect(0,0,canvas.width, canvas.height);

    // background grid glow
    ctx.save();
    ctx.globalAlpha = 0.12;
    for(let y=0; y<ROWS; y++){
      for(let x=0; x<COLS; x++){
        if((x+y)%2===0){
          ctx.fillStyle = "#ffffff";
          ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
        }
      }
    }
    ctx.restore();

    // walls
    for(let y=0; y<ROWS; y++){
      for(let x=0; x<COLS; x++){
        if(MAP[y][x] === "#"){
          // wall block
          ctx.fillStyle = "rgba(120,170,255,.20)";
          ctx.fillRect(x*TILE, y*TILE, TILE, TILE);

          // inner shading
          ctx.fillStyle = "rgba(0,0,0,.22)";
          ctx.fillRect(x*TILE+2, y*TILE+2, TILE-4, TILE-4);
        }
      }
    }

    // foods
    ctx.font = "18px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    for(const f of foods){
      if(f.isPower){
        ctx.save();
        ctx.globalAlpha = 0.95;
        ctx.fillText("âœ¨", f.x, f.y);
        ctx.restore();
      }else{
        ctx.fillText(f.emoji, f.x, f.y);
      }
    }

    // player
    ctx.save();
    const glow = powerTimer > 0 ? 0.55 : 0.25;
    ctx.shadowColor = powerTimer > 0 ? "rgba(255,255,255,.9)" : "rgba(90,140,255,.9)";
    ctx.shadowBlur = 18;
    ctx.fillStyle = powerTimer > 0 ? "rgba(255,255,255,.92)" : "rgba(90,140,255,.92)";
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.r, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // ghosts
    for(const g of ghosts){
      if(g.deadTimer > 0) continue;
      ctx.save();
      ctx.shadowColor = powerTimer > 0 ? "rgba(255,255,255,.55)" : "rgba(255,80,120,.65)";
      ctx.shadowBlur = 18;
      ctx.fillStyle = powerTimer > 0 ? "rgba(255,255,255,.55)" : "rgba(255,80,120,.72)";
      ctx.beginPath();
      ctx.arc(g.x, g.y, g.r, 0, Math.PI*2);
      ctx.fill();

      // face
      ctx.shadowBlur = 0;
      ctx.fillStyle = "rgba(0,0,0,.55)";
      ctx.beginPath();
      ctx.arc(g.x-4, g.y-2, 2.2, 0, Math.PI*2);
      ctx.arc(g.x+4, g.y-2, 2.2, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // overlay text in center for menu/pause/over
    if(state !== "play"){
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,.55)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = "rgba(234,242,255,.95)";
      ctx.font = "700 30px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      const title =
        state === "menu" ? "Eat What You Want" :
        state === "pause" ? "Paused" : "Game Over";

      ctx.fillText(title, canvas.width/2, canvas.height/2 - 32);

      ctx.font = "500 15px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      const sub =
        state === "menu"
          ? "Space / Startë¡œ ì‹œì‘ Â· ìœ ë ¹(ğŸ‘»)ì„ í”¼í•˜ë©´ì„œ ìŒì‹(ğŸ•ğŸœğŸ°)ì„ ë¨¹ì–´!"
          : state === "pause"
          ? "P ë˜ëŠ” Pause ë²„íŠ¼ìœ¼ë¡œ ì¬ê°œ"
          : "R ë˜ëŠ” Resetìœ¼ë¡œ ë‹¤ì‹œ ì‹œì‘";

      ctx.fillStyle = "rgba(234,242,255,.78)";
      ctx.fillText(sub, canvas.width/2, canvas.height/2 + 4);

      ctx.font = "500 13px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillStyle = "rgba(234,242,255,.65)";
      ctx.fillText("âœ¨ëŠ” 5ì´ˆê°„ NO GUILT MODE (ìœ ë ¹ì´ ë„ë§ê° + ìœ ë ¹ë„ ë¨¹ì„ ìˆ˜ ìˆìŒ)", canvas.width/2, canvas.height/2 + 28);
      ctx.restore();
    }

    // HUD
    const wish = eaten.slice(0,6).join(" ");
    leftHud.innerHTML =
      `<b>Score</b> ${score} Â· <b>Lives</b> ${"â¤ï¸".repeat(Math.max(0,lives)) || "0"}<br/>` +
      `<span style="color:rgba(234,242,255,.72)">Message:</span> ${escapeHtml(message)}`;

    rightHud.innerHTML =
      `<b>Wish List</b><br/>` +
      `<span style="color:rgba(234,242,255,.88)">${wish || "â€¦ì•„ì§ ë°°ê³ í””"}</span>` +
      `<div style="margin-top:6px;color:rgba(234,242,255,.72)">${powerTimer>0 ? `NO GUILT ${powerTimer.toFixed(1)}s` : "âœ¨ë¥¼ ë¨¹ìœ¼ë©´ No Guilt Mode"}</div>`;
  }
})();
</script>
</body>
</html>
